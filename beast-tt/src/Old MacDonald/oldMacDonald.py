# Take a file generated by BEAUTi and a CSV file of farm information and make a caseToCase XML file for BEAST. Version 3.1
from __future__ import division
import csv
from lxml import etree
from datetime import datetime
import time
import math
import argparse


patternString = 'caseID'
overallEstInfVar = 0.5

specificSims = True

kernelLookup = {'e': 'exponential', 'p': 'powerLaw', 'g': 'gaussian'}
outbreakLookup = {'s': 'simpleCategory', 'j': 'jeffreysCategory', 'w': 'withinCaseCategory', 'g': 'generalCategory'}
modelLookup = {'s': 'simpleCaseToCase', 'j': 'jeffreysCaseToCase', 'w': 'withinCaseCoalescent', 'g': 'generalCaseToCase'}
fixedKeep = {'taxa', 'treeModel', 'categoryOutbreak', 'simpleOutbreak', 'operators', 'mcmc', 'report'}
startingTrees = {'coalescentSimulator', 'coalescentTree', 'upgmaTree'}
coalescentNames = {'gmrfSkyrideLikelihood', 'coalescentLikelihood'}


# Main method

def modifyXML(csvreader, dayOne, riemannSteps, outputFileName, beautiFileName, fileNameRoot, startingNewick, model, kernel, fixed, latentPeriods):
    
    # TO DO: don't write infectious period elements if you're not modelling them. At present this should be considered a hack.
        
    outbreakString = outbreakLookup[model]+'Outbreak'
    caseString = outbreakLookup[model]+'Case'
    
    modelString = modelLookup[model]
    
    parser = etree.XMLParser(remove_blank_text=True)
    
    fullTree = etree.parse(open(beautiFileName), parser)  
    
    beastElement = fullTree.getroot()
    
    beastElement.addprevious(etree.Comment(" BEAUTi output modified for transmission tree reconstruction by OldMacDonald 4"))
    beastElement.addprevious(etree.Comment("        by Matthew Hall, University of Edinburgh"))
    
    # if running on a fixed tree, strip out all the irrelevent elements
    if fixed:
        for element in beastElement.iterchildren():
            if element.tag not in fixedKeep:
                beastElement.remove(element)  
                
    if model=='w':
        for element in beastElement.iterchildren():
            if element.tag in coalescentNames:
                beastElement.remove(element)
        
    
    # replace the old starting tree if told to do so            
    if startingNewick!=None:
        for element in beastElement.iterchildren():
            if element.tag in startingTrees:
                beastElement.remove(element) 
        treeModelElement = beastElement.find('treeModel')
        for element in treeModelElement.iterchildren():
            if element.tag in startingTrees:
                treeModelElement.insert(treeModelElement.index(element), createReferenceBlock(etree, 'newick', 'startingTree'))
                treeModelElement.remove(element)
        newickElement = etree.Element('newick')
        newickElement.set('id', 'startingTree')
        newickElement.set('usingDates', 'true')
        newickFile = open(startingNewick)
        newickString = newickFile.read()
        newickElement.text = newickString
        
        beastElement.insert(beastElement.index(treeModelElement), newickElement) 
    
    # Remove the old taxa elements
    taxaElement = beastElement.find('taxa')
    for taxon in taxaElement:
        taxaElement.remove(taxon)
    
    operatorsElement = beastElement.find('operators')
    
    # Add the outbreak block
    
    outbreakElement = etree.Element(outbreakString)
    outbreakElement.set('id', 'outbreak')
    outbreakElement.set('hasLatentPeriods', str(latentPeriods).lower())
    outbreakElement.set('hasGeography', str(kernel!='n').lower())
    beastElement.insert(beastElement.index(operatorsElement), outbreakElement)
    beastElement.insert(beastElement.index(outbreakElement), etree.Comment(" Epidemiological information about the "
                                                                           "clinical cases that the sequences were "
                                                                           "taken from"))
    
    infCategoryName = 'inf1'
    latCategoryName = 'lat1' if latentPeriods else None
       
    if model=='w':
        # for now, let's stick with one category
        infDistributionPriorElement = etree.SubElement(outbreakElement, 'infectiousPeriodPrior')
        infDistributionPriorElement.set("categoryName", infCategoryName)
        infDistributionPriorElement.set("mu", "1.0")
        infDistributionPriorElement.set("lambda", "0.5")
        infDistributionPriorElement.set("alpha", "1.0")
        infDistributionPriorElement.set("beta", "0.1")

        if latentPeriods:
            latDistributionPriorElement = etree.SubElement(outbreakElement, 'latentPeriodPrior')
            latDistributionPriorElement.set("categoryName", latCategoryName)
            latDistributionPriorElement.set("mu", "1.0")
            latDistributionPriorElement.set("lambda", "0.5")
            latDistributionPriorElement.set("alpha", "1.0")
            latDistributionPriorElement.set("beta", "0.1")
                
            
        
    
    outbreakElement.append(createReferenceBlock(etree, 'taxa', 'taxa'))

    
    # gather all the branch position elements together (to be added as a child of the tree likelihood element)
    branchPositionsElement = etree.Element('compoundParameter')
    branchPositionsElement.set('id','infectionTimeBranchPositions')
    
    if latentPeriods:
        infnessPositionsElement = etree.Element('compoundParameter')
        infnessPositionsElement.set('id','infectiousTimePositions')
        
    # Individual farm data processing starts here; read from a CSV file. The file must have the column headings "Farm_ID", "Exam_date", "Cull_date", "Oldest_lesion" (for SimpleOutbreaks) and "Taxon".
    # In future there will need to be an infectious category column
    headerRow=csvreader.next()
    farmIDColumn=None
    examDateColumn=None
    cullDateColumn=None
    oldestLesionColumn=None
    taxonColumn=None
    longColumn=None
    latColumn=None
    # Find the correct columns for the required information
    for i in range(0, len(headerRow)):
        if headerRow[i]=='Farm_ID':
            farmIDColumn=i
        elif headerRow[i]=='Exam_date':
            examDateColumn=i
        elif headerRow[i]=='Cull_date':
            cullDateColumn=i
        elif headerRow[i]=='Clinical_guess':
            oldestLesionColumn=i
        elif headerRow[i]=='Taxon':
            taxonColumn=i
        elif headerRow[i]=='Longitude' and kernel!='n':
            longColumn=i
        elif headerRow[i]=='Latitude' and kernel!='n':
            latColumn=i
    if(farmIDColumn==None or examDateColumn==None or cullDateColumn==None or (model=='s' and oldestLesionColumn==None)
       or taxonColumn==None or (kernel!='n' and (latColumn==None or longColumn==None))):
        raise Exception('Not all required columns are present')
    
        # Go through the rows of the CSV file and make a farm XML and a taxon block for each
    currentRow=csvreader.next()
    branchPositionNames = list()
    infnessPositionNames= list()
    while currentRow!=None:  
        processedExamDate = datetime.strptime(currentRow[examDateColumn], '%d/%m/%Y')
        processedCullDate = datetime.strptime(currentRow[cullDateColumn], '%d/%m/%Y')
        intExamDate = (processedExamDate - dayOne).days
        intCullDate = (processedCullDate - dayOne).days
        taxa=currentRow[taxonColumn].split('$')
        taxonElement = etree.SubElement(taxaElement,'taxon')
        taxonElement.set('id', currentRow[taxonColumn])
        samplingDateElement = etree.SubElement(taxonElement,'date')
        # Events (sample and cull) now happen at the _end_ of the day. Easier that way. Hopefully. Still need to add 1, since time 0 is the beginning
        # of day 0, and thus if you subtract day 0's time value from another you get the number of days elapsed between the ends.
        samplingDateElement.set('value', str(intExamDate+1))
        samplingDateElement.set('direction','forwards')
        samplingDateElement.set('units','days')
        samplingDateElement.set('origin', dayOne.strftime('%d/%m/%Y'))
        attributeElement = etree.SubElement(taxonElement,'attr')
        attributeElement.set('name', patternString)
        attributeElement.text = currentRow[farmIDColumn]
        latitude = None
        longitude = None
        if kernel!='n':
            latitude = currentRow[latColumn]
            longitude = currentRow[longColumn]
        # Want to be adding +1 to dates here to get the end of the required days.
        if model=='s':
            outbreakElement.append(createSimpleCaseElement(etree, caseString, currentRow[farmIDColumn], intExamDate+1,
                                                           intCullDate+1, float(currentRow[oldestLesionColumn]), dayOne,
                                                           'sqrt_inf_scale', longitude, latitude, taxa))
        elif model=='j':
            outbreakElement.append(createJeffreysCategoryCaseElement(etree, caseString, currentRow[farmIDColumn],
                                                                     intExamDate+1, intCullDate+1, dayOne, longitude,
                                                                     latitude, taxa, infCategoryName+'dist',
                                                                     latCategoryName+'dist'))
        elif model=='w':
            outbreakElement.append(createWithinCaseCategoryCaseElement(etree, caseString, currentRow[farmIDColumn],
                                                                       intExamDate+1, intCullDate+1, dayOne, longitude,
                                                                       latitude, taxa, infCategoryName+'dist',
                                                                       latCategoryName+'dist'))
        branchPositionsElement.append(createReferenceBlock(etree,'parameter', currentRow[farmIDColumn]+'_bp'))
        branchPositionNames.append(currentRow[farmIDColumn]+'_bp')
        if latentPeriods:
            infnessPositionsElement.append(createReferenceBlock(etree,'parameter', currentRow[farmIDColumn]+'_lbp'))
            infnessPositionNames.append(currentRow[farmIDColumn]+'_lbp')            
        try:
            currentRow=csvreader.next()
        except StopIteration:
            currentRow=None
     
    # Add the C2CL block
    c2cTransElement = etree.Element('caseToCaseTransmissionLikelihood')
    c2cTransElement.set('id', 'c2cTransLikelihood')
    c2cTransElement.set('integratorSteps', str(riemannSteps))
    beastElement.insert(beastElement.index(operatorsElement), c2cTransElement)
    beastElement.insert(beastElement.index(c2cTransElement), etree.Comment(" Probability of the transmission tree and "
                                                                           "epidemiological parameters given the "
                                                                           "phylogenetic tree"))
    
    if kernel!='n':
        kernelElement = etree.SubElement(c2cTransElement, 'spatialKernelFunction')
        kernelElement.set('type', kernelLookup[kernel])
        kernelElement.append(createParameterBlock(etree, 'a', 'kernel_a', 1, True, 1))
        if kernel=='g':
            kernelElement.set('integratorSteps', str(riemannSteps)) 
    trElement = createParameterBlock(etree, 'transmissionRate', 'transmission_rate', 0.05, True, 1)      
    c2cTransElement.append(trElement)
     
    c2cTreeElement = etree.SubElement(c2cTransElement, modelString)
    c2cTreeElement.append(createReferenceBlock(etree, outbreakString, 'outbreak'))
    c2cTreeElement.append(createReferenceBlock(etree,'treeModel','treeModel')) 
    c2cTreeElement.set('id', modelString)
    c2cTreeElement.append(createParameterBlock(etree, 'maxFirstInfToRoot', 'max_first_inf_to_root', 14, True, 1))
    infTimesWrapper = etree.Element('infectionTimeBranchPositions')
    c2cTreeElement.append(infTimesWrapper)
    infTimesWrapper.append(branchPositionsElement)
    if latentPeriods:
        infnessTimesWrapper = etree.Element('infectiousTimePositions')
        c2cTreeElement.append(infnessTimesWrapper)
        infnessTimesWrapper.append(infnessPositionsElement)
    if model=='w':
        demoModelWrapper = etree.Element('demographicModel')
        logisticGrowthElement = etree.SubElement(demoModelWrapper, 'logisticGrowthN0')
        logisticGrowthElement.set('units', 'days')
        logisticGrowthElement.append(createParameterBlock(etree, 'populationSize', 'logistic.startingNe', 1, True, 1))
        logisticGrowthElement.append(createParameterBlock(etree, 'growthRate', 'logistic.growthRate', 1, True, 1))
        logisticGrowthElement.append(createParameterBlock(etree, 't50', 'logistic.t50', 0, False, 1))
        c2cTreeElement.append(demoModelWrapper)
        
    
    operatorsBlock = beastElement.find('operators')
    if not fixed:
        treeOperatorsToRemove = {'narrowExchange', 'wideExchange', 'wilsonBalding', 'subtreeSlide'}
        treeOperatorsToAdd = {'transmissionExchangeOperatorA', 'transmissionExchangeOperatorB',
                              'transmissionWilsonBaldingA', 'transmissionWilsonBaldingB', 'transmissionSubtreeSlideA',
                              'transmissionSubtreeSlideB'}
        for operator in operatorsBlock.iterchildren():
            if operator.tag in treeOperatorsToRemove:
                operatorsBlock.remove(operator)
        for operatorName in treeOperatorsToAdd:
            newOperatorElement = etree.SubElement(operatorsBlock, operatorName)
            newOperatorElement.set('weight', str(8))
            ftlElement = etree.SubElement(newOperatorElement, modelString)
            ftlElement.set('idref', modelString)
            if operatorName.startswith('transmissionSubtreeSlide'):
                newOperatorElement.set('gaussian', 'true')        

    else:
        for operator in operatorsBlock.iterchildren():
            operatorsBlock.remove(operator) 
            
    
        
    ibmElement = etree.SubElement(operatorsBlock,'infectionBranchMovementOperator')
    ibmElement.set('weight', str(5))
    ftlElement = etree.SubElement(ibmElement, modelString)
    ftlElement.set('idref', modelString)

    ibgElement = etree.SubElement(operatorsBlock,'infectionBranchGibbsOperator')
    ibgElement.set('weight', str(5))
    ftlElement = etree.SubElement(ibgElement, 'caseToCaseTransmissionLikelihood')
    ftlElement.set('idref', 'c2cTransLikelihood')

    bpUniformOpElement = etree.SubElement(operatorsBlock, 'uniformOperator')
    bpUniformOpElement.set('weight', str(5))
    bpUniformOpElement.set('lower', str(0))
    bpUniformOpElement.set('upper', str(1))
    bpUniformOpElement.append(createReferenceBlock(etree, 'parameter', 'infectionTimeBranchPositions'))
    
    if latentPeriods:
        bpUniformOpElement = etree.SubElement(operatorsBlock, 'uniformOperator')
        bpUniformOpElement.set('weight', str(5))
        bpUniformOpElement.set('lower', str(0))
        bpUniformOpElement.set('upper', str(1))
        bpUniformOpElement.append(createReferenceBlock(etree, 'parameter', 'infectiousTimePositions'))
        
    
    #===========================================================================
    # 
    # for name in branchPositionNames:
    #     indibpScaleOpElement = etree.SubElement(operatorsBlock, 'uniformOperator')
    #     indibpScaleOpElement.set('weight', str(1))
    #     indibpScaleOpElement.set('lower', str(0))
    #     indibpScaleOpElement.set('upper', str(1))
    #     indibpScaleOpElement.append(createReferenceBlock(etree, 'parameter', name))
    #      
    #===========================================================================
    trScaleOpElement = etree.SubElement(operatorsBlock, 'scaleOperator')
    trScaleOpElement.set('weight', str(5))
    trScaleOpElement.set('scaleFactor', str(0.75))
    trScaleOpElement.append(createReferenceBlock(etree, 'parameter', 'transmission_rate'))
           
    if kernel!='n':    
        kernelaScaleElement = etree.SubElement(operatorsBlock, 'scaleOperator')
        kernelaScaleElement.set('weight', str(5))
        kernelaScaleElement.set('scaleFactor', str(0.75))
        kernelaScaleElement.append(createReferenceBlock(etree, 'parameter', 'kernel_a'))

    if model=='w':

        growthRateScaleElement = etree.SubElement(operatorsBlock, 'scaleOperator')
        growthRateScaleElement.set('weight', str(5))
        growthRateScaleElement.set('scaleFactor', str(0.75))
        growthRateScaleElement.append(createReferenceBlock(etree, 'parameter', 'logistic.growthRate'))

        startingNeScaleElement = etree.SubElement(operatorsBlock, 'scaleOperator')
        startingNeScaleElement.set('weight', str(5))
        startingNeScaleElement.set('scaleFactor', str(0.75))
        startingNeScaleElement.append(createReferenceBlock(etree, 'parameter', 'logistic.startingNe'))

        t50randomWalkElement = etree.SubElement(operatorsBlock, 'randomWalkOperator')
        t50randomWalkElement.set('weight', str(5))
        t50randomWalkElement.set('windowSize', str(1))
        t50randomWalkElement.append(createReferenceBlock(etree, 'parameter', 'logistic.t50'))
                         
             
    mcmcBlock = beastElement.find('mcmc')
    mcmcBlock.set('operatorAnalysis', fileNameRoot+".ops.txt")
    
    posteriorBlock = mcmcBlock.find('posterior')
    priorBlock = posteriorBlock.find('prior')
    if fixed:
        for element in priorBlock.iterchildren():
            priorBlock.remove(element)
#     if specificSims:
#         priorBlock.append(createGammaPriorBlock(etree, 'productStatistic', 'infectious_mean', 12, 1/3, 1))
#         priorBlock.append(createGammaPriorBlock(etree, 'productStatistic', 'infectious_var', 4, 0.25, 0))
#         priorBlock.append(createUniformPriorBlock(etree, 'parameter', 'transmission_rate', 0, 0.15))
#         if(kernel!='n'):
#             priorBlock.append(createUniformPriorBlock(etree, 'parameter', 'kernel_a', 0.25, 12.5))
#         
    if model=='w':
        for element in priorBlock.iterchildren():
            if element.tag in coalescentNames:
                priorBlock.remove(element)
                
    priorBlock.append(createReferenceBlock(etree, 'caseToCaseTransmissionLikelihood', 'c2cTransLikelihood'))
                                          
    likelihoodBlock = posteriorBlock.find('likelihood')
    
    if fixed:
        tlElement = likelihoodBlock.find('treeLikelihood')
        likelihoodBlock.remove(tlElement)
        
    basics = {'prior', 'posterior', 'likelihood'}
    
    for logBlock in mcmcBlock.iterchildren('log'):
        if logBlock.get('id')=='screenLog':   
            if fixed:
                for child in logBlock.iterchildren():
                    columnContents = child[0]
                    if columnContents.tag not in basics:  
                        logBlock.remove(child)  
            logBlock.append(createScreenLogColumnBlock(etree, 'parameter', 'trans_rate', 'transmission_rate', 4, 12))
            
            
            if kernel!='n':
                logBlock.append(createScreenLogColumnBlock(etree, 'parameter', 'kernel_a', 'kernel_a', 4, 12))

        elif logBlock.get('id')=='fileLog':
            logBlock.set('fileName',fileNameRoot+".log.txt")
            logEvery = logBlock.get('logEvery')
            if fixed:
                for child in logBlock.iterchildren():
                    if child.tag not in basics:  
                        logBlock.remove(child)            
            if kernel!='n':
                logBlock.append(createReferenceBlock(etree, 'parameter', 'kernel_a'))
            logBlock.append(createReferenceBlock(etree, 'parameter', 'transmission_rate'))
            logBlock.append(createReferenceBlock(etree, 'caseToCaseTransmissionLikelihood', 'c2cTransLikelihood'))
            if model=='w':
                logBlock.append(createReferenceBlock(etree, 'parameter', 'logistic.growthRate'))
                logBlock.append(createReferenceBlock(etree, 'parameter', 'logistic.startingNe'))
                logBlock.append(createReferenceBlock(etree, 'parameter', 'logistic.t50'))

#             if doGeography:
#                 logBlock.append(createReferenceBlock(etree, 'parameter', 'kernelAlphas'))
    networkLogBlock = etree.Element('log')
    networkLogBlock.set('id', 'networkLog')
    networkLogBlock.set('logEvery', logEvery)
    networkLogBlock.set('fileName', fileNameRoot+".net.txt")
    networkLogBlock.set('overwrite', 'true')
    networkLogBlock.append(createReferenceBlock(etree, modelString, modelString))
    mcmcBlock.insert(mcmcBlock.index(posteriorBlock)+4, networkLogBlock)
    
    treeLogBlock = mcmcBlock.find('logTree')
    treeLogBlock.set('fileName', fileNameRoot+".trees.txt")
    firstTrait = treeLogBlock.find('trait')
    paintingTrait = etree.Element('trait')
    paintingTrait.set('name', 'partition')
    paintingTrait.set('tag', 'partition')
    paintingTrait.append(createReferenceBlock(etree, modelString, modelString))
    treeLogBlock.insert(treeLogBlock.index(firstTrait), paintingTrait)
    if fixed:
        for child in treeLogBlock.iterchildren('trait'):
            if child[0].tag=='discretizedBranchRates':
                treeLogBlock.remove(child)

    fancyTreeLogBlock = etree.Element('logPartitionedTree')
    fancyTreeLogBlock.set('id', 'partitionedTreeFileLog')
    fancyTreeLogBlock.set('logEvery', logEvery)
    fancyTreeLogBlock.set('fileName', fileNameRoot+".fancytrees.txt")
    fancyTreeLogBlock.set('nexusFormat', "true")
    fancyTreeLogBlock.set('sortTranslationTable', "true")
    fancyTreeLogBlock.append(createReferenceBlock(etree, 'treeModel', 'treeModel'))
    fancyTreeLogBlock.append(createReferenceBlock(etree, modelString, modelString))
    fancyTreeLogBlock.append(createNestedReferenceBlock(etree, 'trait', modelString, modelString))
    mcmcBlock.insert(mcmcBlock.index(treeLogBlock)+1, fancyTreeLogBlock)

                  
    # Write to file

    et = etree.ElementTree(beastElement)
    
    
    et.write(outputFileName, pretty_print=True)
    
# Create a block with an enclosing element with name "name", and a parameter element within it with id "id". If greaterThanZero then it has a lower bound of zero.
    
def createParameterBlock(tree, name, idstring, value, greaterThanZero, dim):
    enclosingElement = tree.Element(name)
    parameterElement = tree.SubElement(enclosingElement,'parameter')
    parameterElement.set('value', str(value))
    parameterElement.set('id', idstring)
    if greaterThanZero:
        parameterElement.set('lower', '0.0')
    if dim>1:
        parameterElement.set('dimension', str(dim))
    return enclosingElement

def createUniformPriorBlock(tree, parameterTag, parameterID, lower, upper):
    enclosingElement = tree.Element('uniformPrior')
    innerElement = tree.SubElement(enclosingElement, parameterTag)
    innerElement.set('idref', parameterID)
    enclosingElement.set('lower', str(lower))
    enclosingElement.set('upper', str(upper))
    return enclosingElement

def createGammaPriorBlock(tree, parameterTag, parameterID, shape, scale, offset):
    enclosingElement = tree.Element('gammaPrior')
    innerElement = tree.SubElement(enclosingElement, parameterTag)
    innerElement.set('idref', parameterID)
    enclosingElement.set('shape', str(shape))
    enclosingElement.set('scale', str(scale))
    if offset!=0:
        enclosingElement.set('offset', str(offset))       
    return enclosingElement
    

# Create a block with an enclosing element with name "name", and a parameter element within it with id "id". If greaterThanZero then it has a lower bound of zero. 
    
def createMaxValueParameterBlock(tree, name, idstring, value, maxVal, greaterThanZero, dim):
    enclosingElement = tree.Element(name)
    parameterElement = tree.SubElement(enclosingElement,'parameter')
    parameterElement.set('value', str(value))
    parameterElement.set('id', idstring)
    parameterElement.set('upper', str(maxVal))
    if greaterThanZero:
        parameterElement.set('lower', '0.0')
    if dim>1:
        parameterElement.set('dimension', str(dim))
    return enclosingElement

# Create a block with an enclosing element with name "name" and a gamma distribution element within it.

def createScreenLogColumnBlock(tree, name, label, reference, dp, width):
    columnElement = tree.Element('column')
    columnElement.set('label', label)
    columnElement.set('dp', str(dp))
    columnElement.set('width', str(width))
    innerElement = tree.SubElement(columnElement,name)
    innerElement.set('idref', reference)
    return columnElement

def createExponentialBlock(tree, name, idstring, mean, meanID):
    enclosingElement = tree.Element(name)
    expElement = tree.SubElement(enclosingElement, 'exponentialDistributionModel')
    expElement.append(createParameterBlock(tree, 'mean', meanID, mean, True, 1))
    expElement.set('id', idstring)
    return enclosingElement

def createGammaBlock(tree, name, idstring, scale, shape, scaleID, shapeID):
    enclosingElement = tree.Element(name)
    gammaElement = tree.SubElement(enclosingElement,'gammaDistributionModel')
    gammaElement.append(createParameterBlock(tree, 'shape', shapeID, shape, True, 1))
    gammaElement.append(createParameterBlock(tree, 'scale', scaleID, scale, True, 1))
    gammaElement.set('id', idstring)
    return enclosingElement

def createUnenclosedGammaBlock(tree, idstring, scale, shape, scaleID, shapeID):
    gammaElement = tree.Element('gammaDistributionModel')
    gammaElement.append(createParameterBlock(tree, 'shape', shapeID, shape, True, 1))
    gammaElement.append(createParameterBlock(tree, 'scale', scaleID, scale, True, 1))
    gammaElement.set('id', idstring)
    return gammaElement

def createUpperTruncNormalBlock(xmlBlock, name, idstring, mean, stdev, maximum, meanID, sdID):
    enclosingElement = xmlBlock.createElement(name)
    truncNormalElement = xmlBlock.createElement('truncatedNormalDistributionModel')
    truncNormalElement.appendChild(createParameterBlock(xmlBlock, 'mean', meanID, mean, False, 1))
    truncNormalElement.appendChild(createParameterBlock(xmlBlock, 'stdev', sdID, stdev, True, 1))
    truncNormalElement.appendChild(createParameterBlockNoID(xmlBlock, 'maximum', maximum, False, 1))
    truncNormalElement.setAttribute('id', idstring)
    enclosingElement.appendChild(truncNormalElement)
    return enclosingElement

def createLowerTruncNormalBlock(xmlBlock, name, idstring, mean, stdev, minimum, meanID, sdID):
    enclosingElement = xmlBlock.createElement(name)
    truncNormalElement = xmlBlock.createElement('truncatedNormalDistributionModel')
    truncNormalElement.appendChild(createParameterBlock(xmlBlock, 'mean', meanID, mean, False, 1))
    truncNormalElement.appendChild(createParameterBlock(xmlBlock, 'stdev', sdID, stdev, True, 1))
    truncNormalElement.appendChild(createParameterBlockNoID(xmlBlock, 'minimum', minimum, False, 1))
    truncNormalElement.setAttribute('id', idstring)
    enclosingElement.appendChild(truncNormalElement)
    return enclosingElement

def createLogNormalBlock(xmlBlock, name, idstring, mean, stdev, meanID, sdID):
    enclosingElement = xmlBlock.createElement(name)
    logNormalElement = xmlBlock.createElement('logNormalDistributionModel')
    logNormalElement.setAttribute('meanInRealSpace','true')
    logNormalElement.setAttribute('stdevInRealSpace','true')   
    logNormalElement.appendChild(createParameterBlock(xmlBlock, 'mean', meanID, mean, False, 1))
    logNormalElement.appendChild(createParameterBlock(xmlBlock, 'stdev', sdID, stdev, True, 1))
    logNormalElement.setAttribute('id', idstring)
    enclosingElement.appendChild(logNormalElement)
    return enclosingElement
    
# Create a block with an enclosing element with name "name", and a parameter element within it. If greaterThanZero then it has a lower bound of zero.

def createParameterBlockNoID(tree, name, value, greaterThanZero, dim):
    enclosingElement = tree.Element(name)
    parameterElement = tree.SubElement(enclosingElement,'parameter')
    parameterElement.set('value', str(value))
    if greaterThanZero:
        parameterElement.set('lower', '0.0')
    if dim>1:
        parameterElement.set('dimension', str(dim))
    return enclosingElement

# Create a block with an enclosing element with name "name", and a date element within it with id "id". 

def createEnclosedDateBlock(xmlBlock, name, idstring, value, direction, units, origin):
    enclosingElement = xmlBlock.Element(name)
    dateElement = xmlBlock.Element('date')
    dateElement.set('value', str(value))
    dateElement.set('id', idstring)
    dateElement.set('direction', direction)
    dateElement.set('units', units)
    dateElement.set('origin', str(origin))
    enclosingElement.append(dateElement)
    return enclosingElement

# Create a block with an enclosing element with name "name", and a date element within it. 

def createEnclosedDateBlockNoID(tree, name, value, direction, units, origin):
    enclosingElement = tree.Element(name)
    dateElement = tree.SubElement(enclosingElement,'date')
    dateElement.set('value', str(value))
    dateElement.set('direction', direction)
    dateElement.set('units', units)
    dateElement.set('origin', str(origin))
    return enclosingElement

# Create a block with an enclosing element with name "name" and an integer within it.

def createIntegerBlock(xmlBlock, name, value):
    enclosingElement = xmlBlock.createElement(name)
    integerElement = xmlBlock.createElement('integer')
    integerValue = xmlBlock.createTextNode(str(value))
    integerElement.appendChild(integerValue)
    enclosingElement.appendChild(integerElement)
    return enclosingElement

def createStringBlock(xmlBlock, name, value):
    enclosingElement = xmlBlock.createElement(name)
    stringElement = xmlBlock.createElement('string')
    stringValue = xmlBlock.createTextNode(str(value))
    stringElement.appendChild(stringValue)
    enclosingElement.appendChild(stringElement)
    return enclosingElement

def createIntegerBlockID(xmlBlock, name, myid, value):
    enclosingElement = xmlBlock.createElement(name)
    integerElement = xmlBlock.createElement('integer')
    integerElement.setAttribute('id',myid)
    integerValue = xmlBlock.createTextNode(str(value))
    integerElement.appendChild(integerValue)
    enclosingElement.appendChild(integerElement)
    return enclosingElement

# Create a block of name "name" and an idref to "reference".

def createReferenceBlock(tree, name, reference):
    refBlock = tree.Element(name)
    refBlock.set('idref', reference)
    return refBlock

# Create an enclosed reference block; "parent" is the enclosing block.

def createNestedReferenceBlock(tree, parentName, childName, reference):
    parentBlock = tree.Element(parentName)
    parentBlock.append(createReferenceBlock(tree, childName, reference)) 
    return parentBlock

# Create a farm element

def createSimpleCaseElement(tree, name, caseID, examinationDay, cullDay, oldestLesionAge, dayOne, sqrtInfScaleName, longitude, latitude, taxa):
    caseElement = tree.Element(name)
    caseElement.set('caseID', caseID)
    caseElement.set('id', 'Farm'+caseID)
    caseElement.append(createEnclosedDateBlockNoID(tree, 'examinationDay', examinationDay, 'forwards', 'days', dayOne.strftime('%d/%m/%Y')))
    caseElement.append(createEnclosedDateBlockNoID(tree, 'cullDay', cullDay, 'forwards', 'days', dayOne.strftime('%d/%m/%Y')))
    caseElement.append(createParameterBlockNoID(tree, 'estimatedInfectionDate', oldestLesionAge, True, 1))
    caseElement.append(createMaxValueParameterBlock(tree, 'infectionTimeBranchPosition', caseID+"_bp", 0.5, 1, True, 1))
    
    if longitude!=None and latitude!=None:
        coordsString = str(longitude)+" "+str(latitude)
        caseElement.append(createParameterBlockNoID(tree, 'spatialCoordinates', coordsString, False, 2))
        
                                                   
    # examinationDay-oldestLesionAge is the best guess for the time of infectiousness
    for taxon in taxa:
        caseElement.append(createReferenceBlock(tree, 'taxon', taxon))
    return caseElement


def createJeffreysCategoryCaseElement(tree, name, caseID, examinationDay, cullDay, dayOne, longitude, latitude, taxa, infCategoryName, latCategoryName):
    caseElement = tree.Element(name)
    caseElement.set('caseID', caseID)
    caseElement.set('id', 'Farm'+caseID)
    caseElement.set('inf_category', infCategoryName)
    if latCategoryName!=None:
        caseElement.set('lat_category', latCategoryName)
    caseElement.append(createEnclosedDateBlockNoID(tree, 'examinationDay', examinationDay, 'forwards', 'days', dayOne.strftime('%d/%m/%Y')))
    caseElement.append(createEnclosedDateBlockNoID(tree, 'cullDay', cullDay, 'forwards', 'days', dayOne.strftime('%d/%m/%Y')))
    caseElement.append(createMaxValueParameterBlock(tree, 'infectionTimeBranchPosition', caseID+"_bp", 0.5, 1, True, 1))
    if latCategoryName!=None:
        caseElement.append(createMaxValueParameterBlock(tree, 'infectiousTimePosition', caseID+"_lbp", 0.5, 1, True, 1))
    
    if longitude!=None and latitude!=None:
        coordsString = str(longitude)+" "+str(latitude)
        caseElement.append(createParameterBlockNoID(tree, 'spatialCoordinates', coordsString, False, 2))
                                                   
    # examinationDay-oldestLesionAge is the best guess for the time of infectiousness
    for taxon in taxa:
        caseElement.append(createReferenceBlock(tree, 'taxon', taxon))
    return caseElement

def createWithinCaseCategoryCaseElement(tree, name, caseID, examinationDay, cullDay, dayOne, longitude, latitude, taxa, infCategoryName, latCategoryName):
    caseElement = tree.Element(name)
    caseElement.set('caseID', caseID)
    caseElement.set('id', 'Farm'+caseID)
    caseElement.set('infectiousCategory', infCategoryName)
    caseElement.set('latentCategroy', latCategoryName)
    caseElement.append(createEnclosedDateBlockNoID(tree, 'examinationDay', examinationDay, 'forwards', 'days', dayOne.strftime('%d/%m/%Y')))
    caseElement.append(createEnclosedDateBlockNoID(tree, 'cullDay', cullDay, 'forwards', 'days', dayOne.strftime('%d/%m/%Y')))
    caseElement.append(createMaxValueParameterBlock(tree, 'infectionTimeBranchPosition', caseID+"_bp", 0.5, 1, True, 1))
    if latCategoryName!=None:
        caseElement.append(createMaxValueParameterBlock(tree, 'infectiousTimePosition', caseID+"_lbp", 0.5, 1, True, 1))
    
    if longitude!=None and latitude!=None:
        coordsString = str(longitude)+" "+str(latitude)
        caseElement.append(createParameterBlockNoID(tree, 'spatialCoordinates', coordsString, False, 2))
                                                   
    # examinationDay-oldestLesionAge is the best guess for the time of infectiousness
    for taxon in taxa:
        caseElement.append(createReferenceBlock(tree, 'taxon', taxon))
    return caseElement


def convertOperatorElement(tree, operatorsElement, operatorElement, c2cReference):
    operatorsElement.remove(operatorElement)
    ttoElement = tree.SubElement(operatorsElement, 'transmissionTreeOperator')
    ttoElement.append(operatorElement)
    ttoElement.append(createReferenceBlock(tree, 'caseToCaseTransmissionLikelihood', c2cReference))
    

def pickGammaParameters(mode, variance):
    scale = (-mode+math.sqrt(math.pow(mode,2)+(4*variance)))/2
    shape = variance/math.pow(scale,2)    
    return [shape,scale]
    
# Turn a date to a fractional year. Probably deprecated at this point.
    
def toYearFraction(date):
    def sinceEpoch(date): # returns seconds since epoch
        return time.mktime(date.timetuple())
    
    s = sinceEpoch

    year = date.year
    startOfThisYear = datetime(year=year, month=1, day=1)
    startOfNextYear = datetime(year=year+1, month=1, day=1)

    yearElapsed = s(date) - s(startOfThisYear)
    yearDuration = s(startOfNextYear) - s(startOfThisYear)
    fraction = yearElapsed/yearDuration

    return date.year + fraction

def argOrNone(argument):
    try:
        variable = argument
    except:
        variable = None
    return variable



# Main method; command line entry for data that isn't in the CSV file. If the command has a second argument, it is the XML filename to be written to. Otherwise, it writes to "eieio.xml" ;-) 

def main():
    dayOne = None
    riemannSteps = None
    model = None
    fixed = False
    latentPeriods = False
    kernel = 'e'
    startingNewick = None
    
    validKernels = {'e', 'p', 'g', 'n'}
    validModels = {'s', 'j', 'w', 'g'}

    parser = argparse.ArgumentParser(description='Write XML for the CaseToCaseTransmissionLikelihood class in BEAST', prog="oldMacDonald")
    parser.add_argument('beautiFile', help='The path of an existing XML file generated by BEAUTi or similar, ready to have the elements for transmission tree reconstruction added')
    parser.add_argument('epiFile', help='The path of a CSV file of epidemiological information; the file must have columns "Farm_ID", "Taxon", "Exam_date", "Cull_date" and "Oldest_lesion"')
    parser.add_argument('outputXMLFile', help='The name of the output XML file')
    parser.add_argument('fileNameRoot', help='The root of the file names that BEAST will write the output to')
    parser.add_argument('-d', '--dayOne', help='A date to be used as day 1 of the model (before any plausible TMRCA, use dd/mm/yyyy format)')
    parser.add_argument('-r', '--riemannSteps', help='The number of Riemann numerical integrator steps to use', type=int)
    parser.add_argument('-m', '--model', help='Case model (s=SimpleOutbreak, j=JeffreysCategoryOutbreak, g=GeneralCategoryOutbreak, w-WithinCaseCoalescent)')
    parser.add_argument('-k', '--kernel', help='The type of spatial kernel to use (e=exponential, p=power law, g=Gaussian, n=none (ignore geography)')
    parser.add_argument('-l', '--latentPeriods', help='The model of time from infection to cull includes a latent period')
    parser.add_argument('-s', '--startingTree', help='If a Newick filename is given here, use this as the starting tree')
    parser.add_argument('-f', '--fixed', help='Run on a fixed tree (requires given starting tree)?')
    
    arguments = parser.parse_args()
  
    rawName = arguments.epiFile
    #    At some point you're going to have to make this check the CSV file for the correct column headings. But not now.       
    csvreader = csv.reader(open(rawName, 'rU'))
    outputFileName = arguments.outputXMLFile
    fileNameRoot = arguments.fileNameRoot
    beautiFileName = arguments.beautiFile
    startingNewick = arguments.startingTree
    
    try:
        model = arguments.model
    except:
        pass
    while model not in validModels:
        model = raw_input('Enter a type of model (s=SimpleOutbreak, j=JeffreysCategoryOutbreak, g=GeneralCategoryOutbreak, w-WithinCaseCoalescent): ')            
    
    try:
        dayOne = arguments.dayOne  
    except:
        while dayOne==None:
            try:
                dayOne = raw_input('Enter a date to be used as day 1 of the model (before any plausible TMRCA, use dd/mm/yyyy format): ')
            except:
                print "Please enter a valid date (dd/mm/yy format)"
    try:
        riemannSteps = arguments.riemannSteps
    except:
        while riemannSteps == None:
            try:
                riemannSteps = float(raw_input('Enter number of Riemann numerical integrator steps to use: '))
            except:
                print "Please enter a valid decimal number"
                

    if arguments.kernel in validKernels:
        kernel = arguments.kernel
            
    try:
        fixed = bool(arguments.fixed=="True") 
    except:
        fixedE = raw_input('Fix the tree?')
        if fixedE == "Y":
            fixed = True 
            
    try:
        latentPeriods = bool(arguments.latentPeriods=="True") 
    except:
        latentE = raw_input('Model latent periods?')
        if latentE == "Y":
            latentPeriods = True 
  
           
    
    modifyXML(csvreader, datetime.strptime(dayOne, '%d/%m/%Y'), riemannSteps, outputFileName, beautiFileName, fileNameRoot, startingNewick, model, kernel, fixed, latentPeriods) 

if __name__ == '__main__':
    main()

