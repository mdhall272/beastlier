# Take a file generated by BEAUTi and a CSV file of host information and make a caseToCase XML file for BEAST 1.
from __future__ import division
import csv

from xml.etree.ElementTree import ElementTree
from datetime import datetime
import time
import math
import argparse

dayOne = datetime.strptime("01/01/2000", '%d/%m/%Y')

patternString = 'caseID'
overallEstInfVar = 0.5

specificSims = True

kernelLookup = {'e': 'exponential', 'p': 'powerLaw', 'g': 'gaussian', 'n': 'none'}
fixedKeep = {'taxa', 'treeModel', 'categoryOutbreak', 'operators', 'mcmc', 'report'}
startingTrees = {'coalescentSimulator', 'coalescentTree', 'upgmaTree'}
coalescentNames = {'gmrfSkyrideLikelihood', 'coalescentLikelihood', gmrfSkyGridLikelihood}
hyperpriorLookup = {'n' : 'normalPeriodPriorDistribution',
                    'i' : 'individualPrior'}

# Main method

def modifyXML(csvreader, outputFileName, beautiFileName, fileNameRoot, startingNewick, startingTT,
              model, kernel, distanceMatrix, fixedPT, fixedTT, infHyperprior, latentPeriods, chainLength, sampleEvery,
              dateFormat, fixedClockRate, ratio):

    parseAsDates = dateFormat != None

    latentPeriods = latHyperprior is not 'z'

    modelString = modelLookup[model]

    infHyperpriorLog = infHyperprior.startswith('l')
    infHyperpriorType = hyperpriorLookup[infHyperprior[-1:]]

    if latentPeriods:
        latHyperpriorLog = latHyperprior.startswith('l')
        latHyperpriorType = hyperpriorLookup[latHyperprior[-1:]]

    outbreakString = outbreakLookup[model]+'Outbreak'
    caseString = outbreakLookup[model]+'Case'

    parser = etree.XMLParser(remove_blank_text=True)

    fullTree = etree.parse(open(beautiFileName), parser)

    beastElement = fullTree.getroot()

    beastElement.addprevious(etree.Comment(" BEAUTi output modified for transmission tree reconstruction by "
                                           "OldMacDonald 4"))
    beastElement.addprevious(etree.Comment("        by Matthew Hall, University of Edinburgh"))

    # if running on a fixed tree, strip out all the irrelevent elements
    # if fixed:
    #     for element in beastElement.iterchildren():
    #         if element.tag not in fixedKeep:
    #             beastElement.remove(element)

    for tag in coalescentNames:
        for element in beastElement.iter(tag):
            beastElement.remove(element)

    treeModelElement = beastElement.find('treeModel')
    treeModelElement.tag = 'partitionedTreeModel'

    # replace the old starting tree if told to do so
    if startingNewick!=None:
        for element in beastElement.iterchildren():
            if element.tag in startingTrees:
                beastElement.remove(element)
        for element in treeModelElement.iterchildren():
            if element.tag in startingTrees:
                treeModelElement.insert(treeModelElement.index(element), createReferenceBlock(etree, 'newick',
                                                                                              'startingTree'))
                treeModelElement.remove(element)
        newickElement = etree.Element('newick')
        newickElement.set('id', 'startingTree')
        newickElement.set('usingDates', 'true')
        newickFile = open(startingNewick)
        newickString = newickFile.read()
        newickElement.text = newickString

        beastElement.insert(beastElement.index(treeModelElement), newickElement)


    if fixedClockRate:
        strictClockBranchRatesElement = beastElement.find('strictClockBranchRates')
        clockRateElement = strictClockBranchRatesElement.find('rate')
        clockRateParameterElement = clockRateElement.find('parameter')
        clockRateParameterElement.set('value', '1E-5')


    # Remove the old taxa elements
    taxaElement = beastElement.find('taxa')
    for taxon in taxaElement:
        taxaElement.remove(taxon)

    operatorsElement = beastElement.find('operators')

    # Add the outbreak block

    outbreakElement = etree.Element(outbreakString)
    outbreakElement.set('id', 'outbreak')
    outbreakElement.set('hasLatentPeriods', str(latentPeriods).lower())
    outbreakElement.set('hasGeography', str(kernel!='n').lower())

    beastElement.insert(beastElement.index(operatorsElement), outbreakElement)
    beastElement.insert(beastElement.index(outbreakElement), etree.Comment(" Epidemiological information about the "
                                                                           "clinical cases that the sequences were "
                                                                           "taken from"))

    infCategoryName = 'inf1'
    latCategoryName = 'lat1' if latentPeriods else None


    if model == 'w' or model == 'j' or model =='n' or model =='l':
        # for now, let's stick with one category

        infWrapperElement = etree.SubElement(outbreakElement, 'infectiousPeriodPrior')

        infDistributionPriorElement = etree.SubElement(infWrapperElement, infHyperpriorType)
        infDistributionPriorElement.set("id", infCategoryName+'dist')
        infDistributionPriorElement.set("log", str(infHyperpriorLog).lower())

        if infHyperpriorType=='normalPeriodPriorDistribution':
            infDistributionPriorElement.set("mu", "10")
            infDistributionPriorElement.set("lambda", "100")
            infDistributionPriorElement.set("alpha", "1")
            infDistributionPriorElement.set("beta", "1")
        elif infHyperpriorType=='exponentiallyDistributedStDevPeriodPriorDistribution':
            infDistributionPriorElement.set('lambda', '1')
        elif infHyperpriorType == 'knownVarianceNormalPeriodPriorDistribution':
            infDistributionPriorElement.set("mu0", "8")
            infDistributionPriorElement.set("sigma0", "10")
            infDistributionPriorElement.set("sigma", "1")
        elif infHyperpriorType == 'individualPrior':
            distributionWrapperElement = etree.SubElement(infDistributionPriorElement, 'distribution')
            specificDistributionElement = etree.SubElement(distributionWrapperElement, 'normalDistributionModel')
            meanElement = etree.SubElement(specificDistributionElement, 'mean')
            meanElement.text = str(12)
            stDevElement = etree.SubElement(specificDistributionElement, 'stdev')
            stDevElement.text = str(1)

        if latentPeriods:

            # todo the bit you keep changing is here

            latentPeriodStart = 2 if fixedTT else 0.0001

            if latHyperpriorType == 'latentPeriod':

                latWrapperElement = etree.SubElement(outbreakElement, 'latentPeriods')
                latParameterElement = etree.SubElement(latWrapperElement, "parameter")
                latParameterElement.set("value", str(latentPeriodStart))
                latParameterElement.set("lower", "0")
                latParameterElement.set("id", latCategoryName+".latPeriod")

            else :

                latWrapperElement = etree.SubElement(outbreakElement, 'latentPeriodPrior')

                latDistributionPriorElement = etree.SubElement(latWrapperElement, latHyperpriorType)
                latDistributionPriorElement.set("id", latCategoryName+'dist')
                if(latHyperpriorType is not 'i'):
                    latDistributionPriorElement.set("log", str(latHyperpriorLog).lower())
                else:
                    latDistributionPriorElement.set("log", "false")

                if latHyperpriorType == 'normalPeriodPriorDistribution':
                    latDistributionPriorElement.set("mu", "0")
                    latDistributionPriorElement.set("lambda", "10")
                    latDistributionPriorElement.set("alpha", "100000")
                    latDistributionPriorElement.set("beta", "1000")

                elif latHyperpriorType == 'exponentiallyDistributedStDevPeriodPriorDistribution':
                    latDistributionPriorElement.set('lambda', '1')

                elif latHyperpriorType == 'individualPrior':
                    distributionWrapperElement = etree.SubElement(latDistributionPriorElement, 'distribution')
                    specificDistributionElement = etree.SubElement(distributionWrapperElement, 'logNormalDistributionModel')
                    meanElement = etree.SubElement(specificDistributionElement, 'mean')
                    meanElement.text = str(0)
                    stDevElement = etree.SubElement(specificDistributionElement, 'stdev')
                    stDevElement.text = str(0.1)
                    specificDistributionElement.set('meanInRealSpace','false')

                elif latHyperpriorType == 'knownVarianceNormalPeriodPriorDistribution':
                    latDistributionPriorElement.set("mu0", "0")
                    latDistributionPriorElement.set("sigma0", "0.1")
                    latDistributionPriorElement.set("sigma", "0.1")




    outbreakElement.append(createReferenceBlock(etree, 'taxa', 'taxa'))


    # gather all the branch position elements together (to be added as a child of the tree likelihood element)
    branchPositionsElement = etree.Element('compoundParameter')
    branchPositionsElement.set('id','infectionTimeBranchPositions')

    if latentPeriods:
        infnessPositionsElement = etree.Element('compoundParameter')
        infnessPositionsElement.set('id','infectiousTimePositions')

    # Individual farm data processing starts here; read from a CSV file. The file must have the column headings
    # "Farm_ID", "Exam_date", "Cull_date", "Oldest_lesion" (for SimpleOutbreaks) and "Taxon". In future there will
    # need to be an infectious category column
    headerRow=csvreader.next()
    farmIDColumn=None
    examTimeColumn=None
    cullTimeColumn=None
    oldestLesionColumn=None
    taxonColumn=None
    longColumn=None
    latColumn=None
    bpColumn=None
    itpColumn=None
    # Find the correct columns for the required information
    for i in range(0, len(headerRow)):
        if headerRow[i]=='Farm_ID':
            farmIDColumn=i
        elif headerRow[i]=='Exam_time':
            examTimeColumn=i
        elif headerRow[i]=='Cull_time':
            cullTimeColumn=i
        elif headerRow[i]=='Clinical_guess':
            oldestLesionColumn=i
        elif headerRow[i]=='Taxon':
            taxonColumn=i
        elif headerRow[i]=='Longitude' and kernel!='n':
            longColumn=i
        elif headerRow[i]=='Latitude' and kernel!='n':
            latColumn=i
        elif headerRow[i]=='BP':
            bpColumn=i
        elif headerRow[i]=='ITP':
            itpColumn=i

    # todo correct problem where both distance matrix and coordinates are given

    if(farmIDColumn is None or examTimeColumn is None or cullTimeColumn is None
       or (model=='s' and oldestLesionColumn is None) or taxonColumn is None
       or (kernel!='n' and (distanceMatrix is None and (latColumn is None or longColumn is None)))):
        raise Exception('Not all required columns are present')

    # Go through the rows of the CSV file and make a farm XML and a taxon block for each

    currentRow = csvreader.next()
    branchPositionNames = list()
    infnessPositionNames = list()

    caseCount = 0

    while currentRow!=None:



        latitude = None
        longitude = None
        if kernel!='n' and distanceMatrix is None:
            latitude = currentRow[latColumn]
            longitude = currentRow[longColumn]

        if(currentRow[examTimeColumn]!="NA"):



            if(parseAsDates):
                processedExamDate = datetime.strptime(currentRow[examTimeColumn], dateFormat)
                processedCullDate = datetime.strptime(currentRow[cullTimeColumn], dateFormat)
                examTime = (processedExamDate - dayOne).days
                cullTime = (processedCullDate - dayOne).days
            else:
                examTime = currentRow[examTimeColumn]
                cullTime = currentRow[cullTimeColumn]

            taxa=currentRow[taxonColumn].split('$')
            taxonElement = etree.SubElement(taxaElement,'taxon')
            taxonElement.set('id', currentRow[taxonColumn])
            samplingDateElement = etree.SubElement(taxonElement,'date')
            samplingDateElement.set('value', str(examTime))
            samplingDateElement.set('direction','forwards')
            samplingDateElement.set('units','days')
            attributeElement = etree.SubElement(taxonElement,'attr')
            attributeElement.set('name', patternString)
            attributeElement.text = currentRow[farmIDColumn]


            if(bpColumn is not None and getBPs):
                bp = currentRow[bpColumn]
                if latentPeriods and model !='l':
                    itp = currentRow[itpColumn]
                else:
                    itp = 0.1
            else:
                bp = 0.5
                itp = 0.1


            # Wa
            # nt to be adding +1 to dates here to get the end of the required days
            latString = None

            if latCategoryName!=None and model!='l':
                latString = latCategoryName+'dist'

            if latCategoryName!=None and model=='l':
                latString = latCategoryName+".latPeriod"

            if model=='s':
                outbreakElement.append(createSimpleCaseElement(etree, caseString, currentRow[farmIDColumn], examTime,
                                                               cullTime, float(currentRow[oldestLesionColumn]),
                                                               'sqrt_inf_scale', longitude, latitude, taxa))
            elif model=='j':
                outbreakElement.append(createJeffreysCategoryCaseElement(etree, caseString, currentRow[farmIDColumn],
                                                                         examTime, cullTime, longitude,
                                                                         latitude, taxa, infCategoryName+'dist',
                                                                         latString))
            elif model == 'w' or model == 'n' or model =='l':
                outbreakElement.append(createWithinCaseCategoryCaseElement(etree, caseString, currentRow[farmIDColumn],
                                                                           examTime, cullTime, longitude,
                                                                           latitude, bp, itp, taxa, infCategoryName+'dist',
                                                                           latString, model == 'l'))
            branchPositionsElement.append(createReferenceBlock(etree,'parameter', currentRow[farmIDColumn]+'_bp'))
            branchPositionNames.append(currentRow[farmIDColumn]+'_bp')

            caseCount = caseCount + 1

            if latentPeriods and model != "l":
                infnessPositionsElement.append(createReferenceBlock(etree,'parameter', currentRow[farmIDColumn]+'_lbp'))
                infnessPositionNames.append(currentRow[farmIDColumn]+'_lbp')
        else:

            if model == 'w' or model == 'n' or model =='l':
                outbreakElement.append(createNoninfectedWithinCaseCategoryCaseElement(etree, caseString, currentRow[farmIDColumn], longitude, latitude))



        try:
            currentRow=csvreader.next()
        except StopIteration:
            currentRow=None

    # Add the C2CL block
    c2cTransElement = etree.Element('caseToCaseTransmissionLikelihood')
    c2cTransElement.set('id', 'c2cTransLikelihood')
    beastElement.insert(beastElement.index(operatorsElement), c2cTransElement)
    beastElement.insert(beastElement.index(c2cTransElement), etree.Comment(" Probability of the transmission tree and "
                                                                           "epidemiological parameters given the "
                                                                           "phylogenetic tree"))

    if kernel!='n':
        kernelElement = etree.SubElement(c2cTransElement, 'spatialKernelFunction')
        kernelElement.set('type', kernelLookup[kernel])
        kernelElement.append(createParameterBlock(etree, 'parameters', 'kernel.alpha', 1, True, 1))
        if kernel=='g':
            kernelElement.set('integratorSteps', str(20))
    trElement = createParameterBlock(etree, 'transmissionRate', 'transmission_rate', 0.05, True, 1)

    indexPriorElement = etree.SubElement(c2cTransElement, 'initialInfectionTimePrior')
    normalDistElement = etree.SubElement(indexPriorElement, 'normalDistributionModel')
    meanElement = etree.SubElement(normalDistElement, 'mean')
    sdElement = etree.SubElement(normalDistElement, 'stdev')
    meanElement.text = "0"
    sdElement.text = "2"


    c2cTransElement.append(trElement)

    # trPriorElement = etree.SubElement(c2cTransElement, 'transmissionRatePrior')
    # betaPriorElement = etree.SubElement(trPriorElement, 'scaledBetaDistributionModel')
    # betaAlphaElement = createParameterBlockNoID(etree, 'alpha', '15', 'true', '1')
    # betaPriorElement.append(betaAlphaElement)
    # betaBetaElement = createParameterBlockNoID(etree, 'beta', '5', 'true', '1')
    # betaPriorElement.append(betaBetaElement)
    # betaLengthElement = createParameterBlockNoID(etree, 'length', '0.1', 'true', '1')
    # betaPriorElement.append(betaLengthElement)

    # uniformPriorElement = etree.SubElement(trPriorElement, 'uniformDistributionModel')
    # uniformLowerElement = createParameterBlockNoID(etree, 'lower', '0', 'true', '1')
    # uniformPriorElement.append(uniformLowerElement)
    # uniformUpperElement = createParameterBlockNoID(etree, 'upper', '0.5', 'true', '1')
    # uniformPriorElement.append(uniformUpperElement)

    # gammaPriorElement = etree.SubElement(trPriorElement, 'gammaDistributionModel')
    # gammaScaleElement = createParameterBlockNoID(etree, 'scale', '0.05', 'true', '1')
    # gammaPriorElement.append(gammaScaleElement)
    # gammaShapeElement = createParameterBlockNoID(etree, 'shape', '2', 'true', '1')
    # gammaPriorElement.append(gammaShapeElement)

    c2cTreeElement = etree.SubElement(c2cTransElement, modelString)

    c2cTreeElement.set("truncate", "true")

    if startingTT is not None:
        startingTTElement = etree.SubElement(c2cTreeElement, 'startingNetwork')
        startingTTElement.text = startingTT

    c2cTreeElement.append(createReferenceBlock(etree, outbreakString, 'outbreak'))
    c2cTreeElement.append(createReferenceBlock(etree,'treeModel','treeModel'))
    c2cTreeElement.set('id', modelString)
    c2cTreeElement.append(createParameterBlock(etree, 'maxFirstInfToRoot', 'max_first_inf_to_root', 14, True, 1))
    infTimesWrapper = etree.Element('infectionTimeBranchPositions')
    c2cTreeElement.append(infTimesWrapper)
    infTimesWrapper.append(branchPositionsElement)
    if latentPeriods and model !='l':
        infnessTimesWrapper = etree.Element('infectiousTimePositions')
        c2cTreeElement.append(infnessTimesWrapper)
        infnessTimesWrapper.append(infnessPositionsElement)
    if model == 'w' or model == 'n' or model == 'l':
        demoModelWrapper = etree.Element('demographicModel')
        # constantElement = etree.SubElement(demoModelWrapper, 'linearGrowth')
        # constantElement.set('units', 'days')
        # constantElement.append(createParameterBlock(etree, 'slope', 'lin.slope', 1, True, 1))
        logisticElement = etree.SubElement(demoModelWrapper, 'logisticGrowthN0')
        logisticElement.set('units', 'days')
        logisticElement.append(createParameterBlock(etree, 'populationSize', 'logistic.startingNe', 0.1, True, 1))
        logisticElement.append(createParameterBlock(etree, 'growthRate', 'logistic.growthRate', 1, False, 1))
        logisticElement.append(createParameterBlock(etree, 't50', 'logistic.t50', -4, False, 1))
        c2cTreeElement.append(demoModelWrapper)
        minusStatistic = etree.SubElement(c2cTreeElement, 'negativeStatistic')
        minusStatistic.set('id', 'minusT50')
        minusStatistic.append(createReferenceBlock(etree, 'parameter', 'logistic.t50'))

        if ratio:
            ratioStatistic = etree.SubElement(c2cTreeElement, 'sumStatistic')
            ratioStatistic.set('id', 'logistic.ratio')
            oneElement = etree.SubElement(ratioStatistic, 'parameter')
            oneElement.set('value', '1')
            expElement = etree.SubElement(ratioStatistic, 'exponentialStatistic')
            productElement = etree.SubElement(expElement, 'productStatistic')
            productElement.append(createReferenceBlock(etree, 'parameter', 'logistic.growthRate'))
            productElement.append(createReferenceBlock(etree, 'negativeStatistic', 'minusT50'))






    keepIDrefs = {'clock.rate', 'kappa'}

    operatorsBlock = beastElement.find('operators')
    if not fixedPT:
        treeOperatorsToRemove = {'narrowExchange', 'wideExchange', 'wilsonBalding', 'subtreeSlide'}
        treeOperatorsToAdd = {'transmissionExchangeOperatorA', 'transmissionExchangeOperatorB',
                              'transmissionWilsonBaldingA', 'transmissionWilsonBaldingB', 'transmissionSubtreeSlideA',
                              'transmissionSubtreeSlideB'}
        for operator in operatorsBlock.iterchildren():
            if operator.tag in treeOperatorsToRemove:
                operatorsBlock.remove(operator)
            if model == 'w' or model == 'n' or model == 'l':
                if operator.tag == 'gmrfBlockUpdateOperator':
                    operatorsBlock.remove(operator)
        for operatorName in treeOperatorsToAdd:
            newOperatorElement = etree.SubElement(operatorsBlock, operatorName)
            newOperatorElement.set('weight', str(8))
            newOperatorElement.set('resampleInfectionTimes', 'true')
            ftlElement = etree.SubElement(newOperatorElement, modelString)
            ftlElement.set('idref', modelString)
            if operatorName.startswith('transmissionSubtreeSlide'):
                newOperatorElement.set('gaussian', 'true')
    else:
        for operator in operatorsBlock.iterchildren():
            if operator[0].get("idref") not in keepIDrefs:
                operatorsBlock.remove(operator)

    if distanceMatrix is not None:
        outbreakElement.append(createParameterBlock(etree,'distanceMatrix','distanceMatrix', distanceMatrix, True,
                                                    str(caseCount*caseCount)))

    if not fixedTT:
        ibmElement = etree.SubElement(operatorsBlock,'infectionBranchMovementOperator')
        ibmElement.set('weight', str(15))
        ibmElement.set('resampleInfectionTimes', 'true')
        ftlElement = etree.SubElement(ibmElement, modelString)
        ftlElement.set('idref', modelString)

    # ibgElement = etree.SubElement(operatorsBlock,'infectionBranchGibbsOperator')
    # ibgElement.set('weight', str(1))
    # ftlElement = etree.SubElement(ibgElement, 'caseToCaseTransmissionLikelihood')
    # ftlElement.set('idref', 'c2cTransLikelihood')

        bpUniformOpElement = etree.SubElement(operatorsBlock, 'uniformOperator')
        bpUniformOpElement.set('weight', str(5))
        bpUniformOpElement.set('lower', str(0))
        bpUniformOpElement.set('upper', str(1))
        bpUniformOpElement.append(createReferenceBlock(etree, 'parameter', 'infectionTimeBranchPositions'))

        if latentPeriods and model != 'l':
            bpUniformOpElement = etree.SubElement(operatorsBlock, 'uniformOperator')
            bpUniformOpElement.set('weight', str(5))
            bpUniformOpElement.set('lower', str(0))
            bpUniformOpElement.set('upper', str(1))
            bpUniformOpElement.append(createReferenceBlock(etree, 'parameter', 'infectiousTimePositions'))


    #===========================================================================
    #
    # for name in branchPositionNames:
    #     indibpScaleOpElement = etree.SubElement(operatorsBlock, 'uniformOperator')
    #     indibpScaleOpElement.set('weight', str(1))
    #     indibpScaleOpElement.set('lower', str(0))
    #     indibpScaleOpElement.set('upper', str(1))
    #     indibpScaleOpElement.append(createReferenceBlock(etree, 'parameter', name))
    #
    #===========================================================================

    transRateScaleElement = etree.SubElement(operatorsBlock, 'scaleOperator')
    transRateScaleElement.set('weight', str(5))
    transRateScaleElement.set('scaleFactor', str(0.75))
    transRateScaleElement.append(createReferenceBlock(etree, 'parameter', 'transmission_rate'))

    if fixedClockRate:
        for operator in operatorsBlock.iterchildren():
            if operator[0].get("idref")=='clock.rate':
                operatorsBlock.remove(operator)
            # if operator[0].get("idref")=='kappa':
            #     operatorsBlock.remove(operator)
            if operator.tag == 'upDownOperator':
                operatorsBlock.remove(operator)

    if fixedPT:
        for operator in operatorsBlock.iterchildren():
            if operator[0].get("idref")=='clock.rate':
                operatorsBlock.remove(operator)
            if operator[0].get("idref")=='kappa':
                operatorsBlock.remove(operator)
            if operator.tag == 'upDownOperator':
                operatorsBlock.remove(operator)

    if kernel!='n':
        kernelaScaleElement = etree.SubElement(operatorsBlock, 'scaleOperator')
        kernelaScaleElement.set('weight', str(5))
        kernelaScaleElement.set('scaleFactor', str(0.75))
        kernelaScaleElement.append(createReferenceBlock(etree, 'parameter', 'kernel.alpha'))

    # if model == 'w' or model == 'n' or model == 'l':

        growthRateScaleElement = etree.SubElement(operatorsBlock, 'scaleOperator')
        growthRateScaleElement.set('weight', str(5))
        growthRateScaleElement.set('scaleFactor', str(0.75))
        growthRateScaleElement.append(createReferenceBlock(etree, 'parameter', 'logistic.growthRate'))

        startingNeScaleElement = etree.SubElement(operatorsBlock, 'scaleOperator')
        startingNeScaleElement.set('weight', str(5))
        startingNeScaleElement.set('scaleFactor', str(0.75))
        startingNeScaleElement.append(createReferenceBlock(etree, 'parameter', 'logistic.startingNe'))

        # startingNeScaleElement = etree.SubElement(operatorsBlock, 'scaleOperator')
        # startingNeScaleElement.set('weight', str(5))
        # startingNeScaleElement.set('scaleFactor', str(0.75))
        # startingNeScaleElement.append(createReferenceBlock(etree, 'parameter', 'lin.slope'))


        ttScaleElement = etree.SubElement(operatorsBlock, 'scaleOperator')
        ttScaleElement.set('weight', str(5))
        ttScaleElement.set('scaleFactor', str(0.75))
        ttScaleElement.append(createReferenceBlock(etree, 'parameter', 'logistic.t50'))



    if latHyperpriorType == 'latentPeriod' and not fixedTT:
        latentPeriodScaleElement = etree.SubElement(operatorsBlock, 'scaleOperator')
        latentPeriodScaleElement.set('weight', str(5))
        latentPeriodScaleElement.set('scaleFactor', str(0.75))
        latentPeriodScaleElement.append(createReferenceBlock(etree, 'parameter', latCategoryName+".latPeriod"))


    mcmcBlock = beastElement.find('mcmc')
    mcmcBlock.set('operatorAnalysis', fileNameRoot+".ops.txt")
    mcmcBlock.set('chainLength', str(chainLength))

    posteriorBlock = mcmcBlock.find('posterior')
    priorBlock = posteriorBlock.find('prior')
    # if fixed:
    #     for element in priorBlock.iterchildren():
    #         priorBlock.remove(element)
    if model == 'w' or model == 'n' or model =='l':
        for element in priorBlock.iterchildren():
            if element.tag in coalescentNames:
                priorBlock.remove(element)
            if len(element) and element[0].get('idref').startswith('skyride'):
                priorBlock.remove(element)
        # ratePriorBlock = etree.SubElement(priorBlock, 'invGammaPrior')
        # ratePriorBlock.set('shape', '1')
        # ratePriorBlock.set('scale', '5')
        # ratePriorBlock.set('offset', '0')
        # ratePriorBlock.append(createReferenceBlock(etree, 'parameter', 'logistic.growthRate'))
        #
        #
        # minusTTPriorBlock = etree.SubElement(priorBlock, 'invGammaPrior')
        # minusTTPriorBlock.set('shape', '2')
        # minusTTPriorBlock.set('scale', '10')
        # minusTTPriorBlock.set('offset', '0')
        # minusTTPriorBlock.append(createReferenceBlock(etree, 'negativeStatistic', 'minusT50'))


        minusTTPriorBlock = etree.SubElement(priorBlock, 'gammaPrior')
        minusTTPriorBlock.set('shape', '10')
        minusTTPriorBlock.set('scale', '0.5')
        minusTTPriorBlock.append(createReferenceBlock(etree, 'negativeStatistic', 'minusT50'))


        if ratio:
            ratioPriorBlock = etree.SubElement(priorBlock, 'logNormalPrior')
            ratioPriorBlock.set('mean', '4')
            ratioPriorBlock.set('stdev', '0.5')
            ratioPriorBlock.set('offset', '0')
            ratioPriorBlock.set('meanInRealSpace', 'false')
            ratioPriorBlock.append(createReferenceBlock(etree, 'parameter', 'logistic.ratio'))

        trPriorBlock = etree.SubElement(priorBlock, 'exponentialPrior')
        trPriorBlock.set('mean', '0.5')
        trPriorBlock.append(createReferenceBlock(etree, 'parameter', 'transmission_rate'))

        kaPriorBlock = etree.SubElement(priorBlock, 'exponentialPrior')
        kaPriorBlock.set('mean', '1')
        kaPriorBlock.append(createReferenceBlock(etree, 'parameter', 'kernel.alpha'))




        # ratioPriorBlock = etree.SubElement(priorBlock, 'exponentialPrior')
        # ratioPriorBlock.set('mean', '1')
        # ratioPriorBlock.append(createReferenceBlock(etree, 'parameter', 'lin.slope'))




    # if kernel!='n':
    #     kernelAlphaPriorBlock = etree.SubElement(priorBlock, 'exponentialPrior')
    #     kernelAlphaPriorBlock.set('mean', '20')
    #     kernelAlphaPriorBlock.append(createReferenceBlock(etree, 'parameter', 'kernel_a'))

    if latHyperpriorType == 'latentPeriod':
        latentPeriodPriorBlock = etree.SubElement(priorBlock, 'gammaPrior')
        latentPeriodPriorBlock.set('shape', '200')
        latentPeriodPriorBlock.set('scale', '0.01')
        latentPeriodPriorBlock.append(createReferenceBlock(etree, 'parameter', latCategoryName+".latPeriod"))

    priorBlock.append(createReferenceBlock(etree, 'caseToCaseTransmissionLikelihood', 'c2cTransLikelihood'))

    likelihoodBlock = posteriorBlock.find('likelihood')

    basics = {'prior', 'posterior', 'likelihood'}

    for logBlock in mcmcBlock.iterchildren('log'):
        if logBlock.get('id')=='screenLog':
            logBlock.set('logEvery', str(sampleEvery))
            # if fixed:
            #     for child in logBlock.iterchildren():
            #         columnContents = child[0]
            #         if columnContents.tag not in basics:
            #             logBlock.remove(child)
            logBlock.append(createScreenLogColumnBlock(etree, 'parameter', 'trans_rate', 'transmission_rate', 6, 12))


            if kernel!='n':
                logBlock.append(createScreenLogColumnBlock(etree, 'parameter', 'kernel.alpha', 'kernel.alpha', 4, 12))

            if model == 'l':
                logBlock.append(createScreenLogColumnBlock(etree, 'parameter', 'lat.period', 'lat1.latPeriod', 4, 12))

            if model == 'w' or model == 'n' or model =='l':
                if ratio:

                    logBlock.append(createScreenLogColumnBlock(etree, 'parameter', 'lg.ratio', 'logistic.ratio', 4, 12))
                    logBlock.append(createScreenLogColumnBlock(etree, 'productStatistic', 'lg.t50', 'logistic.t50', 4, 12))

                # logBlock.append(createScreenLogColumnBlock(etree, 'parameter', 'lg.t50', 'logistic.t50', 4, 12))

                logBlock.append(createScreenLogColumnBlock(etree, 'parameter', 'lg.gr', 'logistic.growthRate', 4, 12))
                # logBlock.append(createScreenLogColumnBlock(etree, 'parameter', 'lg.Ne', 'logistic.startingNe', 4, 12))

                # logBlock.append(createScreenLogColumnBlock(etree, 'parameter', 'lin.slope', 'lin.slope', 4, 12))

        elif logBlock.get('id')=='fileLog':
            logBlock.set('fileName',fileNameRoot+".log.txt")
            logBlock.set('logEvery', str(sampleEvery))
            # if fixed:
            #     for child in logBlock.iterchildren():
            #         if child.tag not in basics:
            #             logBlock.remove(child)

            if kernel!='n':
                logBlock.append(createReferenceBlock(etree, 'parameter', 'kernel.alpha'))
            logBlock.append(createReferenceBlock(etree, 'parameter', 'transmission_rate'))
            logBlock.append(createReferenceBlock(etree, 'caseToCaseTransmissionLikelihood', 'c2cTransLikelihood'))
            if model == 'l':
                logBlock.append(createReferenceBlock(etree, 'parameter', 'lat1.latPeriod'))


            if model == 'w' or model =='n' or model =='l':
                if ratio:
                    logBlock.append(createReferenceBlock(etree, 'parameter', 'logistic.ratio'))
                    logBlock.append(createReferenceBlock(etree, 'productStatistic', 'logistic.t50'))
                # else:
                # logBlock.append(createReferenceBlock(etree, 'parameter', 'logistic.t50'))
                logBlock.append(createReferenceBlock(etree, 'parameter', 'logistic.growthRate'))
                # logBlock.append(createReferenceBlock(etree, 'parameter', 'logistic.startingNe'))

                # logBlock.append(createReferenceBlock(etree, 'parameter', 'lin.slope'))

                for child in logBlock.iterchildren():
                    if child.get('idref').startswith('skyride') or child.get('idref')=='coalescent':
                        logBlock.remove(child)

#             if doGeography:
#                 logBlock.append(createReferenceBlock(etree, 'parameter', 'kernelAlphas'))
    networkLogBlock = etree.Element('log')
    networkLogBlock.set('id', 'networkLog')
    networkLogBlock.set('logEvery', str(sampleEvery))
    networkLogBlock.set('fileName', fileNameRoot+".net.txt")
    networkLogBlock.set('overwrite', 'true')
    networkLogBlock.append(createReferenceBlock(etree, modelString, modelString))
    mcmcBlock.insert(mcmcBlock.index(posteriorBlock)+4, networkLogBlock)

    treeLogBlock = mcmcBlock.find('logTree')

    # if fixedPT and fixedTT:
    #     mcmcBlock.remove(treeLogBlock)
    # else:
    treeLogBlock.set('fileName', fileNameRoot+".trees.txt")
    treeLogBlock.set('logEvery', str(sampleEvery))
    firstTrait = treeLogBlock.find('trait')
    paintingTrait = etree.Element('trait')
    paintingTrait.set('name', 'partition')
    paintingTrait.set('tag', 'partition')
    paintingTrait.append(createReferenceBlock(etree, modelString, modelString))
    treeLogBlock.insert(treeLogBlock.index(firstTrait), paintingTrait)
# if fixed:
#     for child in treeLogBlock.iterchildren('trait'):
#         if child[0].tag=='strictClockBranchRates':
#             treeLogBlock.remove(child)

    # fancyTreeLogBlock = etree.Element('logPartitionedTree')
    # fancyTreeLogBlock.set('id', 'partitionedTreeFileLog')
    # fancyTreeLogBlock.set('logEvery', str(sampleEvery))
    # fancyTreeLogBlock.set('fileName', fileNameRoot+".fancytrees.txt")
    # fancyTreeLogBlock.set('nexusFormat', "true")
    # fancyTreeLogBlock.set('sortTranslationTable', "true")
    # fancyTreeLogBlock.append(createReferenceBlock(etree, 'treeModel', 'treeModel'))
    # fancyTreeLogBlock.append(createReferenceBlock(etree, modelString, modelString))
    # fancyTreeLogBlock.append(createNestedReferenceBlock(etree, 'trait', modelString, modelString))
    # mcmcBlock.insert(mcmcBlock.index(treeLogBlock)+1, fancyTreeLogBlock)


    # Write to file

    et = etree.ElementTree(beastElement)

    et.write(outputFileName, pretty_print=True)

# Create a block with an enclosing element with name "name", and a parameter element within it with id "id". If greaterThanZero then it has a lower bound of zero.

def createParameterBlock(tree, name, idstring, value, greaterThanZero, dim):
    enclosingElement = tree.Element(name)
    parameterElement = tree.SubElement(enclosingElement,'parameter')
    parameterElement.set('value', str(value))
    parameterElement.set('id', idstring)
    if greaterThanZero:
        parameterElement.set('lower', '0.0')
    if dim>1:
        parameterElement.set('dimension', str(dim))
    return enclosingElement

def createMinMaxParameterBlock(tree, name, idstring, value, min, max, dim):
    enclosingElement = tree.Element(name)
    parameterElement = tree.SubElement(enclosingElement,'parameter')
    parameterElement.set('value', str(value))
    parameterElement.set('id', idstring)
    parameterElement.set('lower', str(min))
    parameterElement.set('upper', str(max))
    if dim>1:
        parameterElement.set('dimension', str(dim))
    return enclosingElement

def createUniformPriorBlock(tree, parameterTag, parameterID, lower, upper):
    enclosingElement = tree.Element('uniformPrior')
    innerElement = tree.SubElement(enclosingElement, parameterTag)
    innerElement.set('idref', parameterID)
    enclosingElement.set('lower', str(lower))
    enclosingElement.set('upper', str(upper))
    return enclosingElement

def createGammaPriorBlock(tree, parameterTag, parameterID, shape, scale, offset):
    enclosingElement = tree.Element('gammaPrior')
    innerElement = tree.SubElement(enclosingElement, parameterTag)
    innerElement.set('idref', parameterID)
    enclosingElement.set('shape', str(shape))
    enclosingElement.set('scale', str(scale))
    if offset!=0:
        enclosingElement.set('offset', str(offset))
    return enclosingElement


# Create a block with an enclosing element with name "name", and a parameter element within it with id "id". If greaterThanZero then it has a lower bound of zero.

def createMaxValueParameterBlock(tree, name, idstring, value, maxVal, greaterThanZero, dim):
    enclosingElement = tree.Element(name)
    parameterElement = tree.SubElement(enclosingElement,'parameter')
    parameterElement.set('value', str(value))
    parameterElement.set('id', idstring)
    parameterElement.set('upper', str(maxVal))
    if greaterThanZero:
        parameterElement.set('lower', '0.0')
    if dim>1:
        parameterElement.set('dimension', str(dim))
    return enclosingElement

# Create a block with an enclosing element with name "name" and a gamma distribution element within it.

def createScreenLogColumnBlock(tree, name, label, reference, sf, width):
    columnElement = tree.Element('column')
    columnElement.set('label', label)
    columnElement.set('sf', str(sf))
    columnElement.set('width', str(width))
    innerElement = tree.SubElement(columnElement,name)
    innerElement.set('idref', reference)
    return columnElement

def createExponentialBlock(tree, name, idstring, mean, meanID):
    enclosingElement = tree.Element(name)
    expElement = tree.SubElement(enclosingElement, 'exponentialDistributionModel')
    expElement.append(createParameterBlock(tree, 'mean', meanID, mean, True, 1))
    expElement.set('id', idstring)
    return enclosingElement

def createGammaBlock(tree, name, idstring, scale, shape, scaleID, shapeID):
    enclosingElement = tree.Element(name)
    gammaElement = tree.SubElement(enclosingElement,'gammaDistributionModel')
    gammaElement.append(createParameterBlock(tree, 'shape', shapeID, shape, True, 1))
    gammaElement.append(createParameterBlock(tree, 'scale', scaleID, scale, True, 1))
    gammaElement.set('id', idstring)
    return enclosingElement

def createUnenclosedGammaBlock(tree, idstring, scale, shape, scaleID, shapeID):
    gammaElement = tree.Element('gammaDistributionModel')
    gammaElement.append(createParameterBlock(tree, 'shape', shapeID, shape, True, 1))
    gammaElement.append(createParameterBlock(tree, 'scale', scaleID, scale, True, 1))
    gammaElement.set('id', idstring)
    return gammaElement

def createUpperTruncNormalBlock(xmlBlock, name, idstring, mean, stdev, maximum, meanID, sdID):
    enclosingElement = xmlBlock.createElement(name)
    truncNormalElement = xmlBlock.createElement('truncatedNormalDistributionModel')
    truncNormalElement.appendChild(createParameterBlock(xmlBlock, 'mean', meanID, mean, False, 1))
    truncNormalElement.appendChild(createParameterBlock(xmlBlock, 'stdev', sdID, stdev, True, 1))
    truncNormalElement.appendChild(createParameterBlockNoID(xmlBlock, 'maximum', maximum, False, 1))
    truncNormalElement.setAttribute('id', idstring)
    enclosingElement.appendChild(truncNormalElement)
    return enclosingElement

def createLowerTruncNormalBlock(xmlBlock, name, idstring, mean, stdev, minimum, meanID, sdID):
    enclosingElement = xmlBlock.createElement(name)
    truncNormalElement = xmlBlock.createElement('truncatedNormalDistributionModel')
    truncNormalElement.appendChild(createParameterBlock(xmlBlock, 'mean', meanID, mean, False, 1))
    truncNormalElement.appendChild(createParameterBlock(xmlBlock, 'stdev', sdID, stdev, True, 1))
    truncNormalElement.appendChild(createParameterBlockNoID(xmlBlock, 'minimum', minimum, False, 1))
    truncNormalElement.setAttribute('id', idstring)
    enclosingElement.appendChild(truncNormalElement)
    return enclosingElement

def createLogNormalBlock(xmlBlock, name, idstring, mean, stdev, meanID, sdID):
    enclosingElement = xmlBlock.createElement(name)
    logNormalElement = xmlBlock.createElement('logNormalDistributionModel')
    logNormalElement.setAttribute('meanInRealSpace','true')
    logNormalElement.setAttribute('stdevInRealSpace','true')
    logNormalElement.appendChild(createParameterBlock(xmlBlock, 'mean', meanID, mean, False, 1))
    logNormalElement.appendChild(createParameterBlock(xmlBlock, 'stdev', sdID, stdev, True, 1))
    logNormalElement.setAttribute('id', idstring)
    enclosingElement.appendChild(logNormalElement)
    return enclosingElement

# Create a block with an enclosing element with name "name", and a parameter element within it. If greaterThanZero then it has a lower bound of zero.

def createParameterBlockNoID(tree, name, value, greaterThanZero, dim):
    enclosingElement = tree.Element(name)
    parameterElement = tree.SubElement(enclosingElement,'parameter')
    parameterElement.set('value', str(value))
    if greaterThanZero:
        parameterElement.set('lower', '0.0')
    if dim>1:
        parameterElement.set('dimension', str(dim))
    return enclosingElement

# Create a block with an enclosing element with name "name", and a date element within it with id "id".

def createEnclosedDateBlock(xmlBlock, name, idstring, value, direction, units, origin):
    enclosingElement = xmlBlock.Element(name)
    dateElement = xmlBlock.Element('date')
    dateElement.set('value', str(value))
    dateElement.set('id', idstring)
    dateElement.set('direction', direction)
    dateElement.set('units', units)
    dateElement.set('origin', str(origin))
    enclosingElement.append(dateElement)
    return enclosingElement

# Create a block with an enclosing element with name "name", and a date element within it.

def createEnclosedDateBlockNoID(tree, name, value, direction, units, origin):
    enclosingElement = tree.Element(name)
    dateElement = tree.SubElement(enclosingElement,'date')
    dateElement.set('value', str(value))
    dateElement.set('direction', direction)
    dateElement.set('units', units)
    dateElement.set('origin', str(origin))
    return enclosingElement

# Create a block with an enclosing element with name "name" and an integer within it.

def createIntegerBlock(xmlBlock, name, value):
    enclosingElement = xmlBlock.createElement(name)
    integerElement = xmlBlock.createElement('integer')
    integerValue = xmlBlock.createTextNode(str(value))
    integerElement.appendChild(integerValue)
    enclosingElement.appendChild(integerElement)
    return enclosingElement

def createStringBlock(xmlBlock, name, value):
    enclosingElement = xmlBlock.createElement(name)
    stringElement = xmlBlock.createElement('string')
    stringValue = xmlBlock.createTextNode(str(value))
    stringElement.appendChild(stringValue)
    enclosingElement.appendChild(stringElement)
    return enclosingElement

def createIntegerBlockID(xmlBlock, name, myid, value):
    enclosingElement = xmlBlock.createElement(name)
    integerElement = xmlBlock.createElement('integer')
    integerElement.setAttribute('id',myid)
    integerValue = xmlBlock.createTextNode(str(value))
    integerElement.appendChild(integerValue)
    enclosingElement.appendChild(integerElement)
    return enclosingElement

# Create a block of name "name" and an idref to "reference".

def createReferenceBlock(tree, name, reference):
    refBlock = tree.Element(name)
    refBlock.set('idref', reference)
    return refBlock

# Create an enclosed reference block; "parent" is the enclosing block.

def createNestedReferenceBlock(tree, parentName, childName, reference):
    parentBlock = tree.Element(parentName)
    parentBlock.append(createReferenceBlock(tree, childName, reference))
    return parentBlock

# Create a farm element

def createSimpleCaseElement(tree, name, caseID, examinationTime, cullTime, oldestLesionAge, longitude, latitude,
                            taxa):
    caseElement = tree.Element(name)
    caseElement.set('caseID', caseID)
    caseElement.set('id', 'Farm'+caseID)
    caseElement.set('examTime', str(examinationTime))
    caseElement.set('cullTime', str(cullTime))
    caseElement.append(createParameterBlockNoID(tree, 'estimatedInfectionDate', oldestLesionAge, True, 1))
    caseElement.append(createMaxValueParameterBlock(tree, 'infectionTimeBranchPosition', caseID+"_bp", 0.5, 1, True, 1))

    if longitude!=None and latitude!=None:
        coordsString = str(longitude)+" "+str(latitude)
        caseElement.append(createParameterBlockNoID(tree, 'spatialCoordinates', coordsString, False, 2))


    # examinationDay-oldestLesionAge is the best guess for the time of infectiousness
    for taxon in taxa:
        caseElement.append(createReferenceBlock(tree, 'taxon', taxon))
    return caseElement


def createJeffreysCategoryCaseElement(tree, name, caseID, examinationTime, cullTime, longitude, latitude, taxa,
                                      infCategoryName, latCategoryName):
    caseElement = tree.Element(name)
    caseElement.set('caseID', caseID)
    caseElement.set('id', 'Farm'+caseID)
    caseElement.set('infectiousCategory', infCategoryName)
    if latCategoryName!=None:
        caseElement.set('latentCategory', latCategoryName)
    caseElement.set('examTime', str(examinationTime))
    caseElement.set('cullTime', str(cullTime))
    caseElement.append(createMaxValueParameterBlock(tree, 'infectionTimeBranchPosition', caseID+"_bp", 0.5, 1, True, 1))
    if latCategoryName!=None:
        caseElement.append(createMaxValueParameterBlock(tree, 'infectiousTimePosition', caseID+"_lbp", 0.5, 1, True, 1))

    if longitude!=None and latitude!=None:
        coordsString = str(longitude)+" "+str(latitude)
        caseElement.append(createParameterBlockNoID(tree, 'spatialCoordinates', coordsString, False, 2))

    # examinationDay-oldestLesionAge is the best guess for the time of infectiousness
    for taxon in taxa:
        caseElement.append(createReferenceBlock(tree, 'taxon', taxon))
    return caseElement

def createWithinCaseCategoryCaseElement(tree, name, caseID, examinationTime, cullTime, longitude, latitude, bp, itp,
                                        taxa, infCategoryName, latCategoryName, fixedLP):
    caseElement = tree.Element(name)
    caseElement.set('wasEverInfected', 'true')
    caseElement.set('caseID', caseID)
    caseElement.set('id', 'Farm'+caseID)
    caseElement.set('infectiousCategory', infCategoryName)
    if latCategoryName!=None:
        caseElement.set('latentCategory', latCategoryName)
    caseElement.set('examTime', str(examinationTime))
    caseElement.set('cullTime', str(cullTime))
    caseElement.append(createMaxValueParameterBlock(tree, 'infectionTimeBranchPosition', caseID+"_bp", bp, 1, True, 1))
    if latCategoryName!=None and not fixedLP:
        caseElement.append(createMaxValueParameterBlock(tree, 'infectiousTimePosition', caseID+"_lbp", itp, 1, True, 1))

    if longitude!=None and latitude!=None:
        coordsString = str(longitude)+" "+str(latitude)
        caseElement.append(createParameterBlockNoID(tree, 'spatialCoordinates', coordsString, False, 2))

    # examinationDay-oldestLesionAge is the best guess for the time of infectiousness
    for taxon in taxa:
        caseElement.append(createReferenceBlock(tree, 'taxon', taxon))
    return caseElement

def createNoninfectedWithinCaseCategoryCaseElement(tree, name, caseID, longitude, latitude):
    caseElement = tree.Element(name)

    caseElement.set('wasEverInfected', 'false')

    caseElement.set('caseID', caseID)
    caseElement.set('id', 'Farm'+caseID)

    if longitude!=None and latitude!=None:
        coordsString = str(longitude)+" "+str(latitude)
        caseElement.append(createParameterBlockNoID(tree, 'spatialCoordinates', coordsString, False, 2))

    return caseElement


def convertOperatorElement(tree, operatorsElement, operatorElement, c2cReference):
    operatorsElement.remove(operatorElement)
    ttoElement = tree.SubElement(operatorsElement, 'transmissionTreeOperator')
    ttoElement.append(operatorElement)
    ttoElement.append(createReferenceBlock(tree, 'caseToCaseTransmissionLikelihood', c2cReference))


def pickGammaParameters(mode, variance):
    scale = (-mode+math.sqrt(math.pow(mode,2)+(4*variance)))/2
    shape = variance/math.pow(scale,2)
    return [shape,scale]

# Turn a date to a fractional year. Probably deprecated at this point.

def toYearFraction(date):
    def sinceEpoch(date): # returns seconds since epoch
        return time.mktime(date.timetuple())

    s = sinceEpoch

    year = date.year
    startOfThisYear = datetime(year=year, month=1, day=1)
    startOfNextYear = datetime(year=year+1, month=1, day=1)

    yearElapsed = s(date) - s(startOfThisYear)
    yearDuration = s(startOfNextYear) - s(startOfThisYear)
    fraction = yearElapsed/yearDuration

    return date.year + fraction

def argOrNone(argument):
    try:
        variable = argument
    except:
        variable = None
    return variable



# Main method; command line entry for data that isn't in the CSV file. If the command has a second argument, it is the XML filename to be written to. Otherwise, it writes to "eieio.xml" ;-)

def main():
    model = None
    fixedPT = False
    fixedTT = False
    latentPeriods = False
    kernel = 'e'
    startingNewick = None
    dateFormat = None
    distanceMatrixPath = None
    startingTT = None
    getBPs = False
    chainLength = 10000000
    sampleEvery = 1000
    ratio = False

    validKernels = {'e', 'p', 'g', 'n'}
    validModels = {'s', 'j', 'w', 'g', 'n', 'l'}
    validInfHyperpriors = {'n', 'v', 's', 'e', 'i', 'ln', 'lv', 'ls', 'le'}
    validLatHyperpriors = {'n', 'v', 's', 'e', 'i', 'ln', 'lv', 'ls', 'le', 'z'}

    parser = argparse.ArgumentParser(description='Write XML for the CaseToCaseTransmissionLikelihood class in BEAST',
                                     prog="oldMacDonald")
    parser.add_argument('beautiFile', help='The path of an existing XML file generated by BEAUTi or similar, ready to '
                                           'have the elements for transmission tree reconstruction added')
    parser.add_argument('epiFile', help='The path of a CSV file of epidemiological information; the file must have '
                                        'columns "Farm_ID", "Taxon", "Exam_date", "Cull_date" and "Oldest_lesion"')
    parser.add_argument('outputXMLFile', help='The name of the output XML file')
    parser.add_argument('fileNameRoot', help='The root of the file names that BEAST will write the output to')
    parser.add_argument('-d', '--dateFormat', help='The date format (see documentation for the datetime library for'
                                                   ' formats) for the date entries in the data table. If absent, times'
                                                   ' of sampling and noninfectiousness are parsed as floating point'
                                                   ' numbers.')
    parser.add_argument('-M', '--distanceMatrixPath', help='Path for a file containing a distance matrix; entries '
                                                           'should be in the same order as the data table. If a spatial'
                                                           ' kernel is to be used either this or coordinates for each '
                                                           'case must be provided')
    parser.add_argument('-m', '--model', help='Case model (s=SimpleOutbreak, j=JeffreysCategoryOutbreak, '
                                              'g=GeneralCategoryOutbreak, w=WithinCaseCoalescent, '
                                              'n=newWithinCaseCoalescent)')
    parser.add_argument('-k', '--kernel', help='The type of spatial kernel to use (e=exponential, p=power law, '
                                               'g=Gaussian, n=none (ignore geography)')
    parser.add_argument('-i', '--infectiousPeriods', help='The hyperprior type for the distribution of infectious '
                                                          'period (n=normal, k=normal (known variance), v=1/variance, '
                                                          's=1/stdev, i=individual prior on each host)')
    parser.add_argument('-l', '--latentPeriods', help='')
    parser.add_argument('-s', '--startingPTree', help='If a Newick filename is given here, use this as the starting '
                                                     'phylogenetic tree')
    parser.add_argument('-t', '--startingTTree', help='If a CSV filename is given here, use this as the starting'
                                                      ' transmission tree (WARNING: this may not be compatible'
                                                      ' with the starting phylogeny')
    parser.add_argument('-b', '--startingBranchPositions')
    parser.add_argument('-f', '--fixedPT', help='Run on a fixed phylogenetic tree (requires given starting tree)?')
    parser.add_argument('-g', '--fixedTT', help='Run on a fixed transmission tree (requires -fixedPT)?')
    parser.add_argument('-c', '--chainLength', help='Length of the MCMC chain')
    parser.add_argument('-e', '--sampleEvery', help='Sampling frequency')

    arguments = parser.parse_args()

    rawName = arguments.epiFile
    #    At some point you're going to have to make this check the CSV file for the correct column headings. But not
    #    now.
    csvreader = csv.reader(open(rawName, 'rU'))
    outputFileName = arguments.outputXMLFile
    fileNameRoot = arguments.fileNameRoot
    beautiFileName = arguments.beautiFile
    startingNewick = arguments.startingPTree
    startingTT = arguments.startingTTree
    chainLength = arguments.chainLength
    sampleEvery = arguments.sampleEvery
    dateFormat = arguments.dateFormat
    distanceMatrixPath = arguments.distanceMatrixPath
    fixedClockRate = arguments.fixedClockRate
    getBPs = bool(arguments.startingBranchPositions=="True")

    try:
        model = arguments.model
    except:
        pass
    while model not in validModels:
        model = raw_input('Enter a type of model (s=SimpleOutbreak, j=JeffreysCategoryOutbreak, '
                          'g=GeneralCategoryOutbreak, w-WithinCaseCoalescent): ')


    if arguments.kernel in validKernels:
        kernel = arguments.kernel

    try:
        fixedPT = bool(arguments.fixedPT=="True")
    except:
        fixedE = raw_input('Fix the phylogeny?')
        if fixedE == "Y":
            fixedPT = True

    try:
        fixedTT = bool(arguments.fixedTT=="True")
    except:
        fixedE = raw_input('Fix the transmission tree?')
        if fixedE == "Y":
            fixedTT = True

    try:
        ratio = bool(arguments.ratio=="True")
    except:
        ratioE = raw_input('Use the ratio prior')
        if ratioE == "Y":
            ratio = True

    fixedClockRateQ = fixedClockRate=="True"

    infHyperprior = arguments.infectiousPeriods

    latHyperprior = arguments.latentPeriods

    if distanceMatrixPath is not None:
        distanceMatrix = open(distanceMatrixPath, 'r').read()
    else :
        distanceMatrix = None



    modifyXML(csvreader, outputFileName, beautiFileName, fileNameRoot, startingNewick, startingTT,
              model, kernel, distanceMatrix, fixedPT, fixedTT, infHyperprior, latHyperprior, chainLength, sampleEvery,
              getBPs, dateFormat, fixedClockRateQ, ratio)


if __name__ == '__main__':
    main()

